diff -r 7cf61c34c3de lockfile.py
--- a/lockfile.py	Sat Nov 24 12:58:04 2007 -0600
+++ lockfile/lockfile.py	Thu Jun 19 19:08:48 2008 -0500
@@ -24,15 +24,22 @@ True
 >>> lock = FileLock(_testfile())
 >>> print lock.is_locked()
 False
->>> with lock:
-...    print lock.is_locked()
-True
+
+## >>> with lock:
+## ...    print lock.is_locked()
+## True
 >>> print lock.is_locked()
 False
->>> # It is okay to lock twice from the same thread...
->>> with lock:
-...     lock.acquire()
-...
+
+# It is okay to lock twice from the same thread...
+## >>> with lock:
+## ...     lock.acquire()
+## ...
+>>> lock.acquire()
+>>> try:
+...   lock.acquire()
+... finally:
+...   lock.release()
 >>> # Though no counter is kept, so you can't unlock multiple times...
 >>> print lock.is_locked()
 False
@@ -53,7 +60,7 @@ To do:
     * Describe on-disk file structures in the documentation.
 """
 
-from __future__ import division, with_statement
+from __future__ import division###, with_statement
 
 import socket
 import os
@@ -343,13 +350,13 @@ class LockBase:
     def __enter__(self):
         """Context manager support.
 
-        >>> lock = FileLock(_testfile())
-        >>> with lock:
-        ...   lock.is_locked()
-        ...
-        True
-        >>> lock.is_locked()
-        False
+        # >>> lock = FileLock(_testfile())
+        # >>> with lock:
+        # ...   lock.is_locked()
+        # ...
+        # True
+        # >>> lock.is_locked()
+        # False
         """
         self.acquire()
         return self
@@ -671,9 +678,13 @@ def _lock_wait_unlock(event1, event2):
     Helper for doctests.
     """
     lock = FileLock(_testfile())
-    with lock:
+##     with lock:
+    lock.acquire()
+    try:
         event1.set()  # we're in,
         event2.wait() # wait for boss's permission to leave
+    finally:
+        lock.release()
 
 def _test():
     global FileLock
